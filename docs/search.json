[{"path":"/articles/balance.html","id":"evaluating-the-balance-in-matched-samples","dir":"Articles","previous_headings":"","what":"Evaluating the balance in matched samples","title":"Balance","text":"package polymatching implements also functions assess balance variables interest matching. Consider matched samples generated Polymatching tab. following code can used assess balance five variables dataset first matched set. table provides standardized mean differences (SMDs) comparing pair groups, matching, terms listed variables. continuous variables, table also provides ratio variances matching. SMDs less 10% generally considered negligible differences. table show -group differences much decreased matching variables taken account matching step (X1X_1, X2X_2 X3X_3). balance ZZ WW, taken account generate first matched sample, poor. Plots graphically show outputs can produced following code. plots SMDs ratios variances distinct elements output.   Notably, considering balance matched set variables ZZ WW exactly matched, possible observe perfect balance variables ZZ WW worse balance variables.","code":"tabBalance_1 <- balance(G ~ X_1 + X_2 + X_3 + Z + W,                         match_id = dat$match_id_1,                         data = dat) knitr::kable(head(tabBalance_1, n = 12), digits = 3) plot_1 <- plotBalance(tabBalance_1,                        boxplots = FALSE,                       ratioVariances = TRUE) #Standardized mean differences plot_1$plotStdzDiff #Ratio of variances plot_1$plotRatioVars tabBalance_3 <- balance(G ~ X_1 + X_2 + X_3 + Z + W,                         match_id = dat$match_id_3,                         data = dat) plot_2 <- plotBalance(tabBalance_3,                        boxplots = FALSE,                       ratioVariances = TRUE) #Standardized mean differences plot_2$plotStdzDiff"},{"path":"/articles/polymatching.html","id":"the-algorithm-a-brief-overview","dir":"Articles","previous_headings":"","what":"The algorithm: a brief overview","title":"Polymatching","text":"polymatching algorithm organized two main stages. First, starting matched sample generated initialize algorithm. Second, iterative procedure applied reduce distance within matched sets, thus improving quality solution. initialization first matched sample, package implements sequential strategy. units first two groups optimally matched. , units third group optimally matched existing pairs. units fourth group optimally matched existing triplets, . Note , step, existing two-group optimal matching procedure can applied problem can addressed two-group matching algorithm (matching units fixed pairs, units fixed triplets ). order considered groups can specified user , default, based size, sequentially matching groups smallest largest. Furthermore, package enables user provide given matched set starting point, algorithm can explore improvement terms total distance. second stage algorithm iterative procedure. example, KK groups, algorithm starts relaxing linkage first group units group rematched fixed (K−1)(K-1)-uples. procedure repeated KK groups attained total distance recorded. newly generated matched set improves total distance, matched sample attaining smallest total distance selected iterations continue. , linkage group sequentially relaxed possible reductions total distance explored. algorithm stops improvement total distance found.","code":""},{"path":"/articles/polymatching.html","id":"a-toy-dataset","dir":"Articles","previous_headings":"","what":"A toy dataset","title":"Polymatching","text":"showcase functionalities polymatching package, let’s start generating toy dataset 3 continuous variables (X1X_1, X2X_2 X3X_3), one binary variable (ZZ) one categorical variable (WW), four levels. units divided 4 groups, labeled , B, C D, different size (nA=10n_A = 10, nB=100n_B = 100, nC=nD=500n_C = n_D = 500). Let GG name variable identifying assigned group. following plot shows distribution continuous variables.  distribution binary categorical variables represented . two figures show good overlap variables.","code":"#Set seed for reproducibility of results set.seed(1234)  #Group sizes n_A <- 50 n_B <- 750 n_C <- n_D <- 1000  #Generate variables separately for each group dat_A <- data.frame(X_1 = rnorm(n_A, mean = 0,  sd = 1),                      X_2 = rnorm(n_A, mean = 5,  sd = 1),                      X_3 = rnorm(n_A, mean = -5,  sd = 1),                      Z = factor(rbinom(n_A, size = 1, prob = .5)),                     W = factor(apply(rmultinom(n_A, size = 1, prob = c(.25, .25, .25, .25)) == 1,                                       MARGIN = 2,                                       FUN = which)),                     G = \"A\",                     stringsAsFactors = FALSE)  dat_B <- data.frame(X_1 = rnorm(n_B, mean = 0,  sd = 1),                     X_2 = rnorm(n_B, mean = 5,  sd = 1),                     X_3 = rnorm(n_B, mean = -5,  sd = 1),                     Z = factor(rbinom(n_B, size = 1, prob = .5)),                    W = factor(apply(rmultinom(n_A, size = 1, prob = c(.25, .25, .25, .25)) == 1,                                       MARGIN = 2,                                       FUN = which)),                    G = \"B\",                    stringsAsFactors = FALSE)  dat_C <- data.frame(X_1 = rnorm(n_C, mean = -0.5,  sd = 1),                     X_2 = rnorm(n_C, mean = 4.5,  sd = 1),                     X_3 = rnorm(n_C, mean = -4.5,  sd = 1),                     Z = factor(rbinom(n_C, size = 1, prob = .2)),                    W = factor(apply(rmultinom(n_A, size = 1, prob = c(.1, .2, .3, .4)) == 1,                                       MARGIN = 2,                                       FUN = which)),                    G = \"C\",                    stringsAsFactors = FALSE)  dat_D <- data.frame(X_1 = rnorm(n_D, mean = 0.5,  sd = 1),                     X_2 = rnorm(n_D, mean = 5.5,  sd = 1),                     X_3 = rnorm(n_D, mean = -5.5,  sd = 1),                     Z = factor(rbinom(n_D, size = 1, prob = .8)),                    W = factor(apply(rmultinom(n_A, size = 1, prob = c(.4, .3, .2, .1)) == 1,                                       MARGIN = 2,                                       FUN = which)),                    G = \"D\",                    stringsAsFactors = FALSE)  dat <- rbind(dat_A, dat_B, dat_C, dat_D) library(ggplot2) library(tidyr)  dat %>%   pivot_longer(cols = c(\"X_1\", \"X_2\", \"X_3\"),                 names_to = \"variable\",                 values_to = \"value\") %>%   ggplot() +    geom_density(aes(x = value, group = G, color = G, after_stat(count))) +   facet_grid(cols = vars(variable), scales = \"free\") +   labs(x = element_blank(), y = element_blank(), color = \"Group\") dat %>%   pivot_longer(cols = c(\"Z\", \"W\"),                 names_to = \"variable\",                 values_to = \"value\") %>%   ggplot() +    geom_bar(aes(x = G, fill = value)) +   facet_grid(cols = vars(variable), scales = \"free\") +   labs(x = \"Group\", y = \"N\", fill = \"Value\")"},{"path":"/articles/polymatching.html","id":"getting-started-with-polymatch","dir":"Articles","previous_headings":"","what":"Getting started with polymatch","title":"Polymatching","text":"function polymatch can used generate matched sets units similar respect desired variables. simplest matched design, matched sets made one unit group. simulated dataset, means creating quadruplets one subject four groups. default design polymatch. following code can used generate matched sets similar respect three continuous variables X1X_1, X2X_2 X3X_3. output shows total distance attained step iterative process. identify generated sets, IDs matched sets can added dataset new variable. can check group made four units, one group. number matched sets 10, size smallest group.","code":"library(polymatching) result_match_1 <- polymatch(G ~ X_1 + X_2 + X_3,                          data = dat,                         distance = \"euclidean\") ## Conditional optimal matching algorithm ## Number of observations:  2800  ## Number of groups:  4  ## Total distance of starting matched sample:  88.663  ## Ended iteration  1  - total distance: 87.388  ## Ended iteration  2  - total distance: 86.546  ## Ended iteration  3  - total distance: 86.246  ## Ended iteration  4  - total distance: 86.119  ## Ended iteration  5  - total distance: 86.057  ## Ended iteration  6  - total distance: 85.897  ## Ended iteration  7  - total distance: 85.871  ## End  ## Number of iterations: 8, total distance:85.871 ## Number of matched sets:  50 dat$match_id_1 <- result_match_1$match_id head(table(dat$match_id_1,        dat$G,        dnn = c(\"Match ID\", \"Group\"))) ##         Group ## Match ID A B C D ##        1 1 1 1 1 ##        2 1 1 1 1 ##        3 1 1 1 1 ##        4 1 1 1 1 ##        5 1 1 1 1 ##        6 1 1 1 1"},{"path":"/articles/polymatching.html","id":"unbalanced-matched-sets","dir":"Articles","previous_headings":"","what":"Unbalanced matched sets","title":"Polymatching","text":"groups B, C D much larger , can also match multiple subjects B, C D subject . can done parameter vectorK function. Now, unit matched 2 units B 3 units C D.","code":"result_match_2 <- polymatch(G ~ X_1 + X_2 + X_3,                          data = dat,                         distance = \"euclidean\",                         vectorK = c(\"A\" = 1,                                      \"B\" = 2,                                     \"C\" = 3,                                     \"D\" = 3)) ## Conditional optimal matching algorithm ## Number of observations:  2800  ## Number of groups:  4  ## Total distance of starting matched sample:  180.687  ## Ended iteration  1  - total distance: 174.613  ## Ended iteration  2  - total distance: 172.622  ## Ended iteration  3  - total distance: 171.770  ## Ended iteration  4  - total distance: 171.084  ## Ended iteration  5  - total distance: 170.499  ## Ended iteration  6  - total distance: 170.457  ## Ended iteration  7  - total distance: 170.011  ## Ended iteration  8  - total distance: 169.903  ## End  ## Number of iterations: 9, total distance:169.903 ## Number of matched sets:  50 dat$match_id_2 <- result_match_2$match_id head(table(dat$match_id_2,        dat$G,        dnn = c(\"Match ID\", \"Group\"))) ##         Group ## Match ID A B C D ##        1 1 2 3 3 ##        2 1 2 3 3 ##        3 1 2 3 3 ##        4 1 2 3 3 ##        5 1 2 3 3 ##        6 1 2 3 3"},{"path":"/articles/polymatching.html","id":"exact-matching-constraints","dir":"Articles","previous_headings":"","what":"Exact matching constraints","title":"Polymatching","text":"possible force algorithm match units share value one variable (multiple variables). can done exactMatch parameter. following code, units value ZZ WW can matched.","code":"result_match_3 <- polymatch(G ~ X_1 + X_2 + X_3,                          data = dat,                         distance = \"euclidean\",                         exactMatch = ~ Z + W) ## Conditional optimal matching algorithm ## Number of observations:  2800  ## Number of groups:  4  ## Total distance of starting matched sample:  198.824  ## Ended iteration  1  - total distance: 193.142  ## Ended iteration  2  - total distance: 189.467  ## Ended iteration  3  - total distance: 187.170  ## Ended iteration  4  - total distance: 185.916  ## Ended iteration  5  - total distance: 185.225  ## End  ## Number of iterations: 6, total distance:185.225 ## Number of matched sets:  50 dat$match_id_3 <- result_match_3$match_id"},{"path":"/articles/polymatching.html","id":"propensity-score-matching","dir":"Articles","previous_headings":"","what":"Propensity score matching","title":"Polymatching","text":"popular strategy balance multiple covariates match propensity score. two-group setting, defined probability receiving treatment exposure interest commonly estimated logistic regression. multiple treatment groups, defined vector probabilities receiving treatment generally estimated multinomial logistic model. 4 groups, model estimates 4 probabilities 3 logits (log(P(G=′′)/P(G=′D′))log(P(G='')/P(G='D')), log(P(G=′B′)/P(G=′D′))log(P(G='B')/P(G='D')), log(P(G=′C′)/P(G=′D′))log(P(G='C')/P(G='D'))). Units generally matched logits propensity score.","code":"library(VGAM) psModel <- vglm(G ~ X_1 + X_2 + X_3 + Z + W,                 family = multinomial,                  data = dat) summary(psModel) ## Call: ## vglm(formula = G ~ X_1 + X_2 + X_3 + Z + W, family = multinomial,  ##     data = dat) ##  ## Coefficients:  ##               Estimate Std. Error z value Pr(>|z|)     ## (Intercept):1  2.06469    1.10818   1.863  0.06244 .   ## (Intercept):2  5.51731    0.45581  12.105  < 2e-16 *** ## (Intercept):3  9.50965    0.53096  17.910  < 2e-16 *** ## X_1:1         -1.02026    0.15302  -6.668 2.60e-11 *** ## X_1:2         -0.59617    0.05961 -10.000  < 2e-16 *** ## X_1:3         -1.06896    0.07168 -14.913  < 2e-16 *** ## X_2:1         -0.38721    0.15348  -2.523  0.01164 *   ## X_2:2         -0.54746    0.06059  -9.035  < 2e-16 *** ## X_2:3         -0.98895    0.07211 -13.714  < 2e-16 *** ## X_3:1          0.43436    0.15035   2.889  0.00387 **  ## X_3:2          0.48762    0.05869   8.309  < 2e-16 *** ## X_3:3          0.90711    0.07007  12.946  < 2e-16 *** ## Z1:1          -1.76926    0.30515  -5.798 6.71e-09 *** ## Z1:2          -1.44146    0.12341 -11.680  < 2e-16 *** ## Z1:3          -2.70446    0.14623 -18.495  < 2e-16 *** ## W2:1           0.74380    0.38497   1.932  0.05334 .   ## W2:2           0.94372    0.14976   6.302 2.95e-10 *** ## W2:3           1.04912    0.19620   5.347 8.93e-08 *** ## W3:1           0.40365    0.42168   0.957  0.33844     ## W3:2           0.96044    0.15184   6.325 2.53e-10 *** ## W3:3           1.53118    0.18787   8.150 3.63e-16 *** ## W4:1           1.31575    0.43265   3.041  0.00236 **  ## W4:2           1.79106    0.18072   9.911  < 2e-16 *** ## W4:3           3.14656    0.20647  15.240  < 2e-16 *** ## --- ## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 ##  ## Names of linear predictors: log(mu[,1]/mu[,4]), log(mu[,2]/mu[,4]),  ## log(mu[,3]/mu[,4]) ##  ## Residual deviance: 4433.518 on 8376 degrees of freedom ##  ## Log-likelihood: -2216.759 on 8376 degrees of freedom ##  ## Number of Fisher scoring iterations: 6  ##  ## No Hauck-Donner effect found in any of the estimates ##  ##  ## Reference group is level  4  of the response logitPS <- predict(psModel, type = \"link\") dat$logit_AvsD <- logitPS[,1] dat$logit_BvsD <- logitPS[,2] dat$logit_CvsD <- logitPS[,3]  result_match_4 <- polymatch(G ~ logit_AvsD + logit_BvsD + logit_CvsD,                              data = dat,                             distance = \"euclidean\") ## Conditional optimal matching algorithm ## Number of observations:  2800  ## Number of groups:  4  ## Total distance of starting matched sample:  72.488  ## Ended iteration  1  - total distance: 71.590  ## Ended iteration  2  - total distance: 70.647  ## Ended iteration  3  - total distance: 70.106  ## Ended iteration  4  - total distance: 69.072  ## Ended iteration  5  - total distance: 68.989  ## Ended iteration  6  - total distance: 68.946  ## Ended iteration  7  - total distance: 68.933  ## End  ## Number of iterations: 8, total distance:68.933 ## Number of matched sets:  50 dat$match_id_4 <- result_match_4$match_id"},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Giovanni Nattino. Author, maintainer. Bo Lu. Author. Chi Song. Author. Henry Xiang. Author.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Nattino G, Lu B, Song C, Xiang H (2024). polymatching: Matching Algorithm Designs Multiple Groups. R package version 0.9.0.","code":"@Manual{,   title = {polymatching: A Matching Algorithm for Designs with Multiple Groups},   author = {Giovanni Nattino and Bo Lu and Chi Song and Henry Xiang},   year = {2024},   note = {R package version 0.9.0}, }"},{"path":[]},{"path":"/index.html","id":"description","dir":"","previous_headings":"","what":"Description","title":"A Matching Algorithm for Designs with Multiple Groups","text":"package implements conditionally optimal matching algorithm, can used generate matched samples designs multiple treatment groups.","code":""},{"path":"/index.html","id":"details","dir":"","previous_headings":"","what":"Details","title":"A Matching Algorithm for Designs with Multiple Groups","text":"Currently, algorithm can applied datasets 3 6 groups generates matched samples one subject per group. package provides functions generate matched sample evaluate balance key covariates.","code":""},{"path":"/index.html","id":"generating-the-matched-sample","dir":"","previous_headings":"","what":"Generating the Matched Sample","title":"A Matching Algorithm for Designs with Multiple Groups","text":"function implementing matching algorithm polymatch. algorithm iterative needs matched sample one subject per group starting point. matched sample can automatically generated polymatch can provided user. algorithm iteratively explores possible reductions total distance matched sample.","code":""},{"path":"/index.html","id":"evaluating-balance-in-covariates","dir":"","previous_headings":"","what":"Evaluating Balance in Covariates","title":"A Matching Algorithm for Designs with Multiple Groups","text":"Balance key covariates can evaluated function balance. Given matched sample set covariates interest, function computes standardized differences ratio variances pair treatment groups study design. 3, 4, 5 6 groups, 3, 6, 10 15 pairs groups balance evaluated matching. result balance can graphically represented plotBalance.","code":""},{"path":"/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"A Matching Algorithm for Designs with Multiple Groups","text":"can install package function install_github package devtools.","code":"library(devtools) install_github(\"gnattino/polymatching\")"},{"path":"/reference/balance.html","id":null,"dir":"Reference","previous_headings":"","what":"Evaluating the Balance of Covariates After Matching — balance","title":"Evaluating the Balance of Covariates After Matching — balance","text":"function balance computes standardized mean differences ratio variances among treatment groups, matching. function computes two measures balance pair treatment groups.","code":""},{"path":"/reference/balance.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Evaluating the Balance of Covariates After Matching — balance","text":"","code":"balance(   formulaBalance,   match_id,   data,   weights_before = NULL,   weights_after = NULL )"},{"path":"/reference/balance.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Evaluating the Balance of Covariates After Matching — balance","text":"formulaBalance Formula form group ~ x_1 + ... + x_p. group variable identifying treatment groups/exposures. balance evaluated covariates x_1,...,x_p. Numeric integer variables treated continuous. Factor variables treated categorical. Factor variables two levels treated binary. match_id Vector identifying matched sets—matched units must identifier. generated polymatch. data data.frame object data. weights_before Optional vector weights observations considered unmatched dataset. compute unweighted standardized mean differences, set weights_before NULL (default). weights_after Vector weights matched dataset. Set NULL (default) compute unweighted standardized mean differences.","code":""},{"path":"/reference/balance.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Evaluating the Balance of Covariates After Matching — balance","text":"data.frame containing standardized differences ratios variances (continuous variables) pair treatment groups. graphical representation results can generated plotBalance.","code":""},{"path":[]},{"path":"/reference/balance.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Evaluating the Balance of Covariates After Matching — balance","text":"","code":"#Generate a datasets with group indicator and four variables: #- var1, continuous, sampled from normal distributions; #- var2, continuous, sampled from beta distributions; #- var3, categorical with 4 levels; #- var4, binary. set.seed(1234567) dat <- data.frame(group = c(rep(\"A\",20),rep(\"B\",60),rep(\"C\",60)),                   var1 = c(rnorm(20,mean=0,sd=1),                            rnorm(60,mean=1,sd=2),                            rnorm(60,mean=-1,sd=2)),                   var2 = c(rbeta(20,shape1=1,shape2=1),                            rbeta(60,shape1=2,shape2=1),                            rbeta(60,shape1=1,shape2=2)),                   var3 = factor(c(rbinom(20,size=3,prob=.4),                                   rbinom(60,size=3,prob=.5),                                   rbinom(60,size=3,prob=.3))),                   var4 = factor(c(rbinom(20,size=1,prob=.5),                                   rbinom(60,size=1,prob=.3),                                   rbinom(60,size=1,prob=.7))))  #Match on propensity score #-------------------------  #With multiple groups, need a multinomial model for the PS library(VGAM) #> Loading required package: stats4 #> Loading required package: splines psModel <- vglm(group ~ var1 + var2 + var3 + var4,                 family=multinomial, data=dat) #Estimated probabilities - 3 for each unit: P(group=A), P(group=B), P(group=C) probsPS <- predict(psModel, type = \"response\") dat$probA <- probsPS[,\"A\"] dat$probB <- probsPS[,\"B\"] dat$probC <- probsPS[,\"C\"] #Estimated logits - 2 for each unit: log(P(group=A)/P(group=C)), log(P(group=B)/P(group=C)) logitPS <- predict(psModel, type = \"link\") dat$logit_AvsC <- logitPS[,1] dat$logit_BvsC <- logitPS[,2]  #Match on logits of PS resultPs <- polymatch(group ~ logit_AvsC + logit_BvsC, data = dat,                     distance = \"euclidean\") #> Conditional optimal matching algorithm #> Number of observations:  140  #> Number of groups:  3  #> Total distance of starting matched sample:  37.878  #> Ended iteration  1  - total distance: 36.229  #> End  #> Number of iterations: 2, total distance:36.229 #> Number of matched sets:  20  dat$match_id_ps <- resultPs$match_id  #Evaluate balance in covariates tabBalancePs <- balance(group ~ var1 + var2 + var3 + var4,                         match_id = dat$match_id_ps, data = dat) tabBalancePs #>    groups variable        type stdzDiffPre ratioVarsPre stdzDiffPost #> 1     A-B     var1  continuous -0.51757085     4.425458   0.18521887 #> 2     A-C     var1  continuous  0.70879687     4.331368  -0.09488064 #> 3     B-C     var1  continuous  0.96044832     1.021723  -0.21982348 #> 4     A-B     var2  continuous -0.31012062     1.089382  -0.05870530 #> 5     A-C     var2  continuous  0.88429601     1.167713   0.15711852 #> 6     B-C     var2  continuous  1.22693868     1.071905   0.22174525 #> 7     A-B     var3 categorical  1.24193881           NA   0.82499540 #> 8     A-C     var3 categorical  0.41021435           NA   0.84149879 #> 9     B-C     var3 categorical  1.51855778           NA   0.24408401 #> 10    A-B     var4      binary  0.79026333           NA   0.43105272 #> 11    A-C     var4      binary -0.03514727           NA   0.21088361 #> 12    B-C     var4      binary -0.83129513           NA  -0.21685960 #>    ratioVarsPost #> 1       2.173137 #> 2       4.184995 #> 3       1.925786 #> 4       1.121038 #> 5       1.003387 #> 6       1.117254 #> 7             NA #> 8             NA #> 9             NA #> 10            NA #> 11            NA #> 12            NA  #You can also represent the standardized mean differences with 'plotBalance' #plotBalance(tabBalancePs, ratioVariances = TRUE)"},{"path":"/reference/balanceBinVar.html","id":null,"dir":"Reference","previous_headings":"","what":"Balance indicators for binary variables — balanceBinVar","title":"Balance indicators for binary variables — balanceBinVar","text":"Balance indicators binary variables","code":""},{"path":"/reference/balanceBinVar.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Balance indicators for binary variables — balanceBinVar","text":"","code":"balanceBinVar(data, varBalance, match_id, varGroup, pairGroups, varWeights)"},{"path":"/reference/balanceCatVar.html","id":null,"dir":"Reference","previous_headings":"","what":"Balance indicators for categorical variables (more than 2 levels) — balanceCatVar","title":"Balance indicators for categorical variables (more than 2 levels) — balanceCatVar","text":"Balance indicators categorical variables (2 levels)","code":""},{"path":"/reference/balanceCatVar.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Balance indicators for categorical variables (more than 2 levels) — balanceCatVar","text":"","code":"balanceCatVar(data, varBalance, match_id, varGroup, pairGroups, varWeights)"},{"path":"/reference/balanceContVar.html","id":null,"dir":"Reference","previous_headings":"","what":"Balance indicators for continuous variables — balanceContVar","title":"Balance indicators for continuous variables — balanceContVar","text":"Balance indicators continuous variables","code":""},{"path":"/reference/balanceContVar.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Balance indicators for continuous variables — balanceContVar","text":"","code":"balanceContVar(data, varBalance, match_id, varGroup, pairGroups, varWeights)"},{"path":"/reference/checkData.html","id":null,"dir":"Reference","previous_headings":"","what":"Check coherence of inputs with data — checkData","title":"Check coherence of inputs with data — checkData","text":"Check coherence inputs data","code":""},{"path":"/reference/checkData.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check coherence of inputs with data — checkData","text":"","code":"checkData(   formulaMatch,   start,   data,   exactMatch,   vectorK,   checkOnePerGroup = TRUE )"},{"path":"/reference/checkInputs.html","id":null,"dir":"Reference","previous_headings":"","what":"Check that type of inputs is appropriate — checkInputs","title":"Check that type of inputs is appropriate — checkInputs","text":"Check type inputs appropriate","code":""},{"path":"/reference/checkInputs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check that type of inputs is appropriate — checkInputs","text":"","code":"checkInputs(   formulaMatch,   start,   data,   distance,   exactMatch,   iterate,   niter_max,   verbose,   vectorK )"},{"path":"/reference/computePairwiseDistances.html","id":null,"dir":"Reference","previous_headings":"","what":"Given a set of units, compute all the pairwise distances. — computePairwiseDistances","title":"Given a set of units, compute all the pairwise distances. — computePairwiseDistances","text":"Given set units, compute pairwise distances.","code":""},{"path":"/reference/computePairwiseDistances.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Given a set of units, compute all the pairwise distances. — computePairwiseDistances","text":"","code":"computePairwiseDistances(   data,   distance,   Sigma,   varGroup,   varsMatch,   dat_stdzDistances )"},{"path":"/reference/condOptMatching.html","id":null,"dir":"Reference","previous_headings":"","what":"Function implementing conditional optimal matching. — condOptMatching","title":"Function implementing conditional optimal matching. — condOptMatching","text":"Optimally matches two sets IDs matched units–varIndexMatch1 varIndexMatch2–respect matching variables varsMatch.","code":""},{"path":"/reference/condOptMatching.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Function implementing conditional optimal matching. — condOptMatching","text":"","code":"condOptMatching(   data,   varIndexMatch1,   varIndexMatch2,   varsMatch,   varGroup,   distance,   Sigma,   varsExactMatch,   k,   dat_stdzDistances )"},{"path":"/reference/evaluateMatching.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute total distance of a matched sample — evaluateMatching","title":"Compute total distance of a matched sample — evaluateMatching","text":"Compute total distance matched sample","code":""},{"path":"/reference/evaluateMatching.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute total distance of a matched sample — evaluateMatching","text":"","code":"evaluateMatching(   data,   varIndexMatch,   varGroup,   varsMatch,   distance,   Sigma,   dat_stdzDistances )"},{"path":"/reference/pairwiseDistance.html","id":null,"dir":"Reference","previous_headings":"","what":"Distance between two units — pairwiseDistance","title":"Distance between two units — pairwiseDistance","text":"Distance two units","code":""},{"path":"/reference/pairwiseDistance.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Distance between two units — pairwiseDistance","text":"","code":"pairwiseDistance(A, B, distance, Sigma)"},{"path":"/reference/plotBalance.html","id":null,"dir":"Reference","previous_headings":"","what":"Summary Plot of Balance in Covariates — plotBalance","title":"Summary Plot of Balance in Covariates — plotBalance","text":"function generates plot summarizing balance covariates.","code":""},{"path":"/reference/plotBalance.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summary Plot of Balance in Covariates — plotBalance","text":"","code":"plotBalance(dataBalance, ratioVariances = FALSE, boxplots = TRUE)"},{"path":"/reference/plotBalance.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summary Plot of Balance in Covariates — plotBalance","text":"dataBalance output balance. ratioVariances Boolean. TRUE, generated plot contains two panels: one standardized differences one ratios variances. FALSE (default), standardized differences represented. boxplots Boolean. TRUE (default), boxplots added plot, show distribution standardized differences ratios variances.","code":""},{"path":"/reference/plotBalance.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summary Plot of Balance in Covariates — plotBalance","text":"least one covariates continuous ratioVariances=TRUE, function generates plot two panels: one standardized differences one ratio variances (continous variables). either covariates categorical/binary ratioVariances=FALSE (), plot standardized differences generated. function also returns list ggplot2 objects corresponding generated plot(s).","code":""},{"path":[]},{"path":"/reference/plotBalance.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Summary Plot of Balance in Covariates — plotBalance","text":"","code":"#See examples of function 'balance'"},{"path":"/reference/polymatch.html","id":null,"dir":"Reference","previous_headings":"","what":"Polymatching — polymatch","title":"Polymatching — polymatch","text":"polymatch generates matched samples designs 10 groups.","code":""},{"path":"/reference/polymatch.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Polymatching — polymatch","text":"","code":"polymatch(   formulaMatch,   start = \"small.to.large\",   data,   distance = \"euclidean\",   exactMatch = NULL,   vectorK = NULL,   iterate = TRUE,   niter_max = 50,   withinGroupDist = TRUE,   verbose = TRUE )"},{"path":"/reference/polymatch.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Polymatching — polymatch","text":"formulaMatch Formula form group ~ x_1 + ... + x_p, group name variable identifying treatment groups/exposures x_1,...,x_p matching variables. start object specifying starting point iterative algorithm. Three types input accepted: start=\"small..large\" (default): starting matched set generated matching groups smallest largest. Users can specify order used match groups starting sample. example, four groups labels \"\",\"B\",\"C\" \"D\", start=\"D-B--C\" generates starting sample matching groups \"D\" \"B\", units \"\" \"D\"-\"B\"pairs, units \"C\" \"D\"-\"B\"-\"\" triplets. Users can provide starting matched set algorithm explore possible reductions total distance. case, start must vector IDs matched sets, .e., vector length equal number rows data matched subjects flagged value non-matched subjects value NA. data data.frame object data. distance String specifying whether distance pairs observations computed Euclidean (\"euclidean\", default) Mahalanobis (\"mahalanobis\") distance. See section 'Details' information. exactMatch Formula form ~ z_1 + ... + z_k, z_1,...,z_k must factor variables. Subjects exactly matched z_1,...,z_k, .e., matched within levels variables. vectorK named vector number subjects group matched set. names vector must labels groups, .e., levels variable identifying treatment groups/exposures. example, case four groups labels \"\",\"B\",\"C\" \"D\" assuming desired design 1:2:3:3 (1 subject , 2 B, 3 C 3 D matched set), parameter set vectorK =  c(\"\" = 1, \"B\" = 2, \"C\" = 3, \"D\" = 3). default, generated matched design includes 1 subject per group matched set, .e, 1:1: ... :1 matched design. iterate Boolean specifying whether iterations done (iterate=TRUE, default) (iterate=FALSE). niter_max Maximum number iterations. Default 50. withinGroupDist Boolean specifying whether distances within treatment/exposure group considered total distance. example, 1:2:3 matched design among groups , B C, parameters controls whether distance two subjects B three pairwise distances among subjects C counted total distance. default value TRUE. verbose Boolean: text printed console? Default TRUE.","code":""},{"path":"/reference/polymatch.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Polymatching — polymatch","text":"list containing following components: match_id numeric vector identifying matched sets—matched units identifier. total_distance Total distance returned matched sample. total_distance_start Total distance starting point.","code":""},{"path":"/reference/polymatch.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Polymatching — polymatch","text":"function implements conditionally optimal matching algorithm, iteratively uses two-group optimal matching steps generate matched samples small total distance. current implementation, possible generate matched samples multiple subjects per group, matching ratio specified vectorK parameter. steps algorithm described following example. Consider 4-group design groups labels \"\", \"B\", \"C\" \"D\" 1:1:1:1 matching ratio. algorithm requires set quadruplets starting point. argument start defines approach used generate starting point. polymatch generates starting point sequentially using optimal two-group matching. default setting (start=\"small..large\"), steps : optimally match two smallest groups; optimally match third smallest group pairs generated first step; optimally match last group triplets generated second step. Notably, can use optimal two-group algorithm steps 2) 3) two-dimensional problems: elements one group one hand, fixed matched sets hand. order groups considered generating starting point can user-specified (e.g., start=\"D-B--C\"). alternative, user can provide matched set used starting point. Given starting matched set, algorithm iteratively explores possible reductions total distance (iterate=\"TRUE\"), sequentially relaxing connection group rematching units group. example: rematch \"B-C-D\" triplets within starting quadruplets units group \"\"; rematch \"-C-D\" triplets within starting quadruplets units group \"B\"; rematch \"-B-D\" triplets within starting quadruplets units group \"C\"; rematch \"-B-C\" triplets within starting quadruplets units group \"D\". none sets quadruplets generated 1)-4) smaller total distance starting point, algorihm stops. Otherwise, set quadruplets smallest distance seleceted process iterated, reduction total distance found number maximum iterations reached (niter_max=50 default). total distance defined sum within-matched-set distances. within-matched-set distance defined sum pairwise distances pairs units matched set. type distance specified distance argument. current implementation supports Euclidean (distance=\"euclidean\") Mahalanobis (distance=\"mahalanobis\") distances. particular, Mahalanobis distance, covariance matrix defined full dataset.","code":""},{"path":[]},{"path":"/reference/polymatch.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Polymatching — polymatch","text":"","code":"#Generate a datasets with group indicator and four variables: #- var1, continuous, sampled from normal distributions; #- var2, continuous, sampled from beta distributions; #- var3, categorical with 4 levels; #- var4, binary. set.seed(1234567) dat <- data.frame(group = c(rep(\"A\",20),rep(\"B\",60),rep(\"C\",60)),                   var1 = c(rnorm(20,mean=0,sd=1),                            rnorm(60,mean=1,sd=2),                            rnorm(60,mean=-1,sd=2)),                   var2 = c(rbeta(20,shape1=1,shape2=1),                            rbeta(60,shape1=2,shape2=1),                            rbeta(60,shape1=1,shape2=2)),                   var3 = factor(c(rbinom(20,size=3,prob=.4),                                   rbinom(60,size=3,prob=.5),                                   rbinom(60,size=3,prob=.3))),                   var4 = factor(c(rbinom(20,size=1,prob=.5),                                   rbinom(60,size=1,prob=.3),                                   rbinom(60,size=1,prob=.7))))  #Match on propensity score #-------------------------  #With multiple groups, need a multinomial model for the PS library(VGAM) psModel <- vglm(group ~ var1 + var2 + var3 + var4,                 family=multinomial, data=dat) #Estimated probabilities - 3 for each unit: P(group=A), P(group=B), P(group=C) probsPS <- predict(psModel, type = \"response\") dat$probA <- probsPS[,\"A\"] dat$probB <- probsPS[,\"B\"] dat$probC <- probsPS[,\"C\"] #Estimated logits - 2 for each unit: log(P(group=A)/P(group=C)), log(P(group=B)/P(group=C)) logitPS <- predict(psModel, type = \"link\") dat$logit_AvsC <- logitPS[,1] dat$logit_BvsC <- logitPS[,2]  #Match on logits of PS resultPs1 <- polymatch(group ~ logit_AvsC + logit_BvsC, data = dat,                     distance = \"euclidean\") #> Conditional optimal matching algorithm #> Number of observations:  140  #> Number of groups:  3  #> Total distance of starting matched sample:  37.878  #> Ended iteration  1  - total distance: 36.229  #> End  #> Number of iterations: 2, total distance:36.229 #> Number of matched sets:  20  dat$match_id_ps1 <- resultPs1$match_id  #Match on probabilities resultPs2 <- polymatch(group ~ probA + probB + probC, data = dat,                        distance = \"euclidean\") #> Conditional optimal matching algorithm #> Number of observations:  140  #> Number of groups:  3  #> Total distance of starting matched sample:  6.596  #> Ended iteration  1  - total distance: 6.479  #> Ended iteration  2  - total distance: 6.390  #> Ended iteration  3  - total distance: 6.368  #> Ended iteration  4  - total distance: 6.368  #> Ended iteration  5  - total distance: 6.368  #> End  #> Number of iterations: 6, total distance:6.368 #> Number of matched sets:  20  dat$match_id_ps2 <- resultPs2$match_id  #Match on covariates #--------------------  #Match on continuous covariates only resultCov1 <- polymatch(group ~ var1 + var2, data = dat,                         distance = \"mahalanobis\") #> Conditional optimal matching algorithm #> Number of observations:  140  #> Number of groups:  3  #> Total distance of starting matched sample:  21.572  #> Ended iteration  1  - total distance: 21.154  #> Ended iteration  2  - total distance: 21.140  #> End  #> Number of iterations: 3, total distance:21.140 #> Number of matched sets:  20  dat$match_id_cov1 <- resultCov1$match_id  #Match on continuous covariates with exact match on categorical/binary variables resultCov2 <- polymatch(group ~ var1 + var2, data = dat,                         distance = \"mahalanobis\",                         exactMatch = ~var3+var4) #> Conditional optimal matching algorithm #> Number of observations:  140  #> Number of groups:  3  #> Total distance of starting matched sample:  43.380  #> Ended iteration  1  - total distance: 40.973  #> Ended iteration  2  - total distance: 40.781  #> End  #> Number of iterations: 3, total distance:40.781 #> Number of matched sets:  16  dat$match_id_cov2 <- resultCov2$match_id"},{"path":"/reference/polymatching.html","id":null,"dir":"Reference","previous_headings":"","what":"Polymatching: Matching in Designs with Multiple Treatment Groups — polymatching","title":"Polymatching: Matching in Designs with Multiple Treatment Groups — polymatching","text":"package implements conditionally optimal matching algorithm, can used generate matched samples designs multiple treatment groups.","code":""},{"path":"/reference/polymatching.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Polymatching: Matching in Designs with Multiple Treatment Groups — polymatching","text":"Currently, algorithm can applied datasets 10 groups generates matched samples one subject per group. package provides functions generate matched sample evaluate balance key covariates.","code":""},{"path":"/reference/polymatching.html","id":"generating-the-matched-sample","dir":"Reference","previous_headings":"","what":"Generating the Matched Sample","title":"Polymatching: Matching in Designs with Multiple Treatment Groups — polymatching","text":"function implementing matching algorithm polymatch. algorithm iterative needs matched sample one subject per group starting point. matched sample can automatically generated polymatch can provided user. algorithm iteratively explores possible reductions total distance matched sample.","code":""},{"path":"/reference/polymatching.html","id":"evaluating-balance-in-covariates","dir":"Reference","previous_headings":"","what":"Evaluating Balance in Covariates","title":"Polymatching: Matching in Designs with Multiple Treatment Groups — polymatching","text":"Balance key covariates can evaluated function balance. Given matched sample set covariates interest, function computes standardized differences ratio variances pair treatment groups study design. 3, 4, 5 6 groups, 3, 6, 10 15 pairs groups balance evaluated matching. result balance can graphically represented plotBalance.","code":""},{"path":"/reference/stdzDistances.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute factor to standardize distances when matching multiple subjects in one group — stdzDistances","title":"Compute factor to standardize distances when matching multiple subjects in one group — stdzDistances","text":"Compute factor standardize distances matching multiple subjects one group","code":""},{"path":"/reference/stdzDistances.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute factor to standardize distances when matching multiple subjects in one group — stdzDistances","text":"","code":"stdzDistances(vectorK, withinGroupDist)"},{"path":"/reference/typeVariable.html","id":null,"dir":"Reference","previous_headings":"","what":"Check type of variable — typeVariable","title":"Check type of variable — typeVariable","text":"Check type variable","code":""},{"path":"/reference/typeVariable.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check type of variable — typeVariable","text":"","code":"typeVariable(variable)"},{"path":"/reference/weighted.variance.html","id":null,"dir":"Reference","previous_headings":"","what":"Function to compute weighted variance — weighted.variance","title":"Function to compute weighted variance — weighted.variance","text":"Function compute weighted variance","code":""},{"path":"/reference/weighted.variance.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Function to compute weighted variance — weighted.variance","text":"","code":"weighted.variance(x, w)"}]
